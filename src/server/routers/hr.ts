import { z } from 'zod'
import { router, publicProcedure } from '../trpc'
import { TRPCError } from '@trpc/server'
import bcrypt from 'bcryptjs'
import { generateRandomPassword, sendPasswordEmail } from '@/lib/email'

export const hrRouter = router({
  // 取得員工列表（人事視角）
  listEmployees: publicProcedure
    .input(z.object({
      companyId: z.string(),
      departmentId: z.string().optional(),
      status: z.enum(['ACTIVE', 'ON_LEAVE', 'RESIGNED']).optional(),
      search: z.string().optional(),
      excludeEmployeeId: z.string().optional(),
    }))
    .query(async ({ ctx, input }) => {
      // 使用 Prisma 在資料庫層進行搜尋（效能優化）
      return ctx.prisma.employeeAssignment.findMany({
        where: {
          companyId: input.companyId,
          ...(input.departmentId && { departmentId: input.departmentId }),
          ...(input.status && { status: input.status }),
          ...(input.excludeEmployeeId && { employeeId: { not: input.excludeEmployeeId } }),
          // 搜尋條件移至資料庫層
          ...(input.search && {
            employee: {
              OR: [
                { name: { contains: input.search, mode: 'insensitive' as const } },
                { employeeNo: { contains: input.search, mode: 'insensitive' as const } },
                { email: { contains: input.search, mode: 'insensitive' as const } },
              ],
            },
          }),
        },
        include: {
          employee: true,
          department: true,
          position: true,
          supervisor: {
            include: {
              employee: { select: { id: true, name: true, employeeNo: true } },
            },
          },
        },
        orderBy: { employee: { employeeNo: 'asc' } },
      })
    }),

  // 取得員工詳細資料
  getEmployee: publicProcedure
    .input(z.object({ employeeId: z.string() }))
    .query(async ({ ctx, input }) => {
      return ctx.prisma.employee.findUnique({
        where: { id: input.employeeId },
        include: {
          assignments: {
            include: {
              company: true,
              department: true,
              position: true,
              role: true,
              supervisor: {
                include: {
                  employee: { select: { name: true } },
                },
              },
            },
            orderBy: { startDate: 'desc' },
          },
        },
      })
    }),

  // 到職作業（建立新員工）
  onboard: publicProcedure
    .input(z.object({
      // 員工基本資料
      employeeNo: z.string(),
      name: z.string(),
      email: z.string().email(),
      password: z.string().optional(), // 可選，若未提供則自動產生
      // 個人資料
      idNumber: z.string().optional(),
      gender: z.enum(['MALE', 'FEMALE', 'OTHER']).optional(),
      birthDate: z.date().optional(),
      phone: z.string().optional(),
      personalEmail: z.string().email().optional(),
      residentialAddress: z.string().optional(),
      householdAddress: z.string().optional(),
      emergencyContact: z.string().optional(),
      emergencyPhone: z.string().optional(),
      // 任職資料
      companyId: z.string(),
      departmentId: z.string(),
      positionId: z.string(),
      supervisorId: z.string().optional(),
      hireDate: z.date(),
      roleId: z.string().optional(),
      operatorId: z.string().optional(), // 操作人 ID（用於異動紀錄）
    }))
    .mutation(async ({ ctx, input }) => {
      // 檢查員工編號是否重複
      const existingNo = await ctx.prisma.employee.findUnique({
        where: { employeeNo: input.employeeNo },
      })
      if (existingNo) {
        throw new TRPCError({ code: 'CONFLICT', message: '員工編號已存在' })
      }

      // 檢查 Email 是否重複
      const existingEmail = await ctx.prisma.employee.findUnique({
        where: { email: input.email },
      })
      if (existingEmail) {
        throw new TRPCError({ code: 'CONFLICT', message: 'Email 已被使用' })
      }

      // 密碼處理：若未提供則自動產生
      let actualPassword = input.password
      const isAutoGenerated = !actualPassword
      if (!actualPassword) {
        actualPassword = generateRandomPassword(12)
      }

      // 密碼規則驗證（只驗證手動輸入的密碼，自動產生的已符合規則）
      if (!isAutoGenerated) {
        const passwordErrors: string[] = []
        if (actualPassword.length < 8) {
          passwordErrors.push('密碼長度至少 8 個字元')
        }
        if (!/[A-Z]/.test(actualPassword)) {
          passwordErrors.push('密碼須包含大寫字母')
        }
        if (!/[a-z]/.test(actualPassword)) {
          passwordErrors.push('密碼須包含小寫字母')
        }
        if (!/[0-9]/.test(actualPassword)) {
          passwordErrors.push('密碼須包含數字')
        }
        if (passwordErrors.length > 0) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: passwordErrors.join('、'),
          })
        }
      }

      // 加密密碼
      const passwordHash = await bcrypt.hash(actualPassword, 10)

      // 取得公司名稱（用於發送 email）
      const company = await ctx.prisma.company.findUnique({
        where: { id: input.companyId },
        select: { name: true },
      })

      // 建立員工與任職記錄
      const employee = await ctx.prisma.employee.create({
        data: {
          employeeNo: input.employeeNo,
          name: input.name,
          email: input.email,
          passwordHash,
          idNumber: input.idNumber,
          gender: input.gender,
          birthDate: input.birthDate,
          phone: input.phone,
          personalEmail: input.personalEmail,
          residentialAddress: input.residentialAddress,
          householdAddress: input.householdAddress,
          emergencyContact: input.emergencyContact,
          emergencyPhone: input.emergencyPhone,
          hireDate: input.hireDate,
          assignments: {
            create: {
              companyId: input.companyId,
              departmentId: input.departmentId,
              positionId: input.positionId,
              supervisorId: input.supervisorId,
              roleId: input.roleId,
              isPrimary: true,
              startDate: input.hireDate,
              status: 'ACTIVE',
            },
          },
        },
        include: {
          assignments: {
            include: {
              company: true,
              department: true,
              position: true,
            },
          },
        },
      })

      // 如果是自動產生密碼，發送通知信
      if (isAutoGenerated) {
        await sendPasswordEmail({
          to: input.email,
          employeeName: input.name,
          employeeNo: input.employeeNo,
          password: actualPassword,
          companyName: company?.name || '公司',
        })
      }

      // 新增入職異動紀錄
      if (input.operatorId) {
        await ctx.prisma.employeeChangeLog.create({
          data: {
            employeeId: employee.id,
            changeType: 'ONBOARD',
            changeDate: input.hireDate,
            toCompanyId: input.companyId,
            toDepartmentId: input.departmentId,
            toPositionId: input.positionId,
            createdById: input.operatorId,
          },
        })
      }

      return employee
    }),

  // 更新員工個人資料
  updateEmployee: publicProcedure
    .input(z.object({
      employeeId: z.string(),
      name: z.string().optional(),
      idNumber: z.string().optional(),
      gender: z.enum(['MALE', 'FEMALE', 'OTHER']).nullable().optional(),
      birthDate: z.date().nullable().optional(),
      phone: z.string().optional(),
      officePhone: z.string().optional(),
      extension: z.string().optional(),
      personalEmail: z.string().email().optional(),
      residentialAddress: z.string().optional(),
      householdAddress: z.string().optional(),
      emergencyContact: z.string().optional(),
      emergencyPhone: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const { employeeId, ...data } = input
      return ctx.prisma.employee.update({
        where: { id: employeeId },
        data,
      })
    }),

  // 更新員工登入資訊（Email 和密碼）- 限管理員使用
  updateEmployeeCredentials: publicProcedure
    .input(z.object({
      employeeId: z.string(),
      email: z.string().email().optional(),
      password: z.string().min(6).optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const { employeeId, email, password } = input

      // 檢查是否有要更新的內容
      if (!email && !password) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: '請提供要更新的 Email 或密碼',
        })
      }

      // 如果要更新 email，檢查是否已被使用
      if (email) {
        const existing = await ctx.prisma.employee.findFirst({
          where: { email, id: { not: employeeId } },
        })
        if (existing) {
          throw new TRPCError({
            code: 'CONFLICT',
            message: '此 Email 已被其他員工使用',
          })
        }
      }

      // 準備更新資料
      const updateData: { email?: string; passwordHash?: string } = {}
      if (email) {
        updateData.email = email
      }
      if (password) {
        updateData.passwordHash = await bcrypt.hash(password, 10)
      }

      return ctx.prisma.employee.update({
        where: { id: employeeId },
        data: updateData,
      })
    }),

  // 離職作業
  offboard: publicProcedure
    .input(z.object({
      employeeId: z.string(),
      resignDate: z.date(),
      reason: z.string().optional(),
      operatorId: z.string().optional(), // 操作人 ID（用於異動紀錄）
    }))
    .mutation(async ({ ctx, input }) => {
      // 取得離職前的任職資料（用於異動紀錄）
      const lastAssignment = await ctx.prisma.employeeAssignment.findFirst({
        where: { employeeId: input.employeeId, status: 'ACTIVE', isPrimary: true },
        select: { companyId: true, departmentId: true, positionId: true },
      })

      // 更新員工離職日期與停用帳號
      await ctx.prisma.employee.update({
        where: { id: input.employeeId },
        data: {
          resignDate: input.resignDate,
          isActive: false,
        },
      })

      // 更新所有任職記錄為離職狀態
      await ctx.prisma.employeeAssignment.updateMany({
        where: { employeeId: input.employeeId, status: 'ACTIVE' },
        data: {
          status: 'RESIGNED',
          endDate: input.resignDate,
        },
      })

      // 新增異動紀錄
      if (input.operatorId && lastAssignment) {
        await ctx.prisma.employeeChangeLog.create({
          data: {
            employeeId: input.employeeId,
            changeType: 'OFFBOARD',
            changeDate: input.resignDate,
            fromCompanyId: lastAssignment.companyId,
            fromDepartmentId: lastAssignment.departmentId,
            fromPositionId: lastAssignment.positionId,
            reason: input.reason,
            createdById: input.operatorId,
          },
        })
      }

      return { success: true }
    }),

  // 復職作業
  reinstate: publicProcedure
    .input(z.object({
      employeeId: z.string(),
      reinstateDate: z.date(),
      companyId: z.string(),
      departmentId: z.string(),
      positionId: z.string(),
      supervisorId: z.string().optional(),
      roleId: z.string().optional(),
      note: z.string().optional(),
      operatorId: z.string(), // 操作人 ID
    }))
    .mutation(async ({ ctx, input }) => {
      // 取得員工資料
      const employee = await ctx.prisma.employee.findUnique({
        where: { id: input.employeeId },
        include: {
          assignments: {
            where: { status: 'RESIGNED' },
            orderBy: { endDate: 'desc' },
            take: 1,
            select: { companyId: true, departmentId: true, positionId: true },
          },
        },
      })

      if (!employee) {
        throw new TRPCError({ code: 'NOT_FOUND', message: '員工不存在' })
      }

      // 檢查是否有有效任職（不可重複復職）
      const activeAssignment = await ctx.prisma.employeeAssignment.findFirst({
        where: { employeeId: input.employeeId, status: 'ACTIVE' },
      })

      if (activeAssignment) {
        throw new TRPCError({ code: 'BAD_REQUEST', message: '該員工已有有效任職記錄，無需復職' })
      }

      // 取得離職前的最後任職資料
      const lastResignedAssignment = employee.assignments[0]

      // 建立新的任職記錄
      await ctx.prisma.employeeAssignment.create({
        data: {
          employeeId: input.employeeId,
          companyId: input.companyId,
          departmentId: input.departmentId,
          positionId: input.positionId,
          supervisorId: input.supervisorId,
          roleId: input.roleId,
          isPrimary: true,
          startDate: input.reinstateDate,
          status: 'ACTIVE',
        },
      })

      // 更新員工狀態
      await ctx.prisma.employee.update({
        where: { id: input.employeeId },
        data: {
          isActive: true,
          resignDate: null, // 清除離職日期
        },
      })

      // 新增復職異動紀錄
      await ctx.prisma.employeeChangeLog.create({
        data: {
          employeeId: input.employeeId,
          changeType: 'REINSTATE',
          changeDate: input.reinstateDate,
          fromCompanyId: lastResignedAssignment?.companyId,
          fromDepartmentId: lastResignedAssignment?.departmentId,
          fromPositionId: lastResignedAssignment?.positionId,
          toCompanyId: input.companyId,
          toDepartmentId: input.departmentId,
          toPositionId: input.positionId,
          note: input.note,
          createdById: input.operatorId,
        },
      })

      return { success: true }
    }),

  // 取得離職員工的最後任職資料（用於復職預設值）
  getLastAssignment: publicProcedure
    .input(z.object({ employeeId: z.string() }))
    .query(async ({ ctx, input }) => {
      const lastAssignment = await ctx.prisma.employeeAssignment.findFirst({
        where: {
          employeeId: input.employeeId,
          status: 'RESIGNED',
          isPrimary: true,
        },
        orderBy: { endDate: 'desc' },
        include: {
          company: { select: { id: true, name: true } },
          department: { select: { id: true, name: true, code: true } },
          position: { select: { id: true, name: true } },
        },
      })

      return lastAssignment
    }),

  // 調動作業
  transfer: publicProcedure
    .input(z.object({
      employeeId: z.string(),
      companyId: z.string(),
      departmentId: z.string(),
      positionId: z.string(),
      supervisorId: z.string().optional(),
      effectiveDate: z.date(),
      operatorId: z.string().optional(), // 操作人 ID（用於異動紀錄）
    }))
    .mutation(async ({ ctx, input }) => {
      // 取得現有主要任職記錄
      const currentAssignment = await ctx.prisma.employeeAssignment.findFirst({
        where: { employeeId: input.employeeId, status: 'ACTIVE', isPrimary: true },
      })

      if (!currentAssignment) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: '找不到員工的現有任職記錄',
        })
      }

      // 檢查是否為同公司內調動
      const isSameCompany = currentAssignment.companyId === input.companyId

      // 新增調動異動紀錄
      if (input.operatorId) {
        await ctx.prisma.employeeChangeLog.create({
          data: {
            employeeId: input.employeeId,
            changeType: 'TRANSFER',
            changeDate: input.effectiveDate,
            fromCompanyId: currentAssignment.companyId,
            fromDepartmentId: currentAssignment.departmentId,
            fromPositionId: currentAssignment.positionId,
            toCompanyId: input.companyId,
            toDepartmentId: input.departmentId,
            toPositionId: input.positionId,
            createdById: input.operatorId,
          },
        })
      }

      if (isSameCompany) {
        // 同公司內調動：直接更新現有記錄的部門和職位
        return ctx.prisma.employeeAssignment.update({
          where: { id: currentAssignment.id },
          data: {
            departmentId: input.departmentId,
            positionId: input.positionId,
            supervisorId: input.supervisorId || null,
            // 可選：更新生效日期
            startDate: input.effectiveDate,
          },
          include: {
            company: true,
            department: true,
            position: true,
          },
        })
      } else {
        // 跨公司調動：結束舊記錄，建立新記錄
        await ctx.prisma.employeeAssignment.update({
          where: { id: currentAssignment.id },
          data: {
            endDate: input.effectiveDate,
            isPrimary: false,
            status: 'RESIGNED',
          },
        })

        // 建立新公司的任職記錄
        return ctx.prisma.employeeAssignment.create({
          data: {
            employeeId: input.employeeId,
            companyId: input.companyId,
            departmentId: input.departmentId,
            positionId: input.positionId,
            supervisorId: input.supervisorId,
            startDate: input.effectiveDate,
            isPrimary: true,
            status: 'ACTIVE',
          },
          include: {
            company: true,
            department: true,
            position: true,
          },
        })
      }
    }),

  // 新增兼任職位（多公司任職）
  addSecondaryAssignment: publicProcedure
    .input(z.object({
      employeeId: z.string(),
      companyId: z.string(),
      departmentId: z.string(),
      positionId: z.string(),
      supervisorId: z.string().optional(),
      startDate: z.date(),
      roleId: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      // 檢查是否已有同公司的 active assignment
      const existingInCompany = await ctx.prisma.employeeAssignment.findFirst({
        where: {
          employeeId: input.employeeId,
          companyId: input.companyId,
          status: 'ACTIVE',
        },
      })

      if (existingInCompany) {
        throw new TRPCError({
          code: 'CONFLICT',
          message: '該員工在此公司已有有效任職記錄，請使用調動功能',
        })
      }

      // 建立新的兼任記錄
      return ctx.prisma.employeeAssignment.create({
        data: {
          employeeId: input.employeeId,
          companyId: input.companyId,
          departmentId: input.departmentId,
          positionId: input.positionId,
          supervisorId: input.supervisorId,
          roleId: input.roleId,
          startDate: input.startDate,
          isPrimary: false,
          status: 'ACTIVE',
        },
        include: {
          company: true,
          department: true,
          position: true,
        },
      })
    }),

  // 結束兼任職位
  endSecondaryAssignment: publicProcedure
    .input(z.object({
      assignmentId: z.string(),
      endDate: z.date(),
    }))
    .mutation(async ({ ctx, input }) => {
      const assignment = await ctx.prisma.employeeAssignment.findUnique({
        where: { id: input.assignmentId },
      })

      if (!assignment) {
        throw new TRPCError({ code: 'NOT_FOUND', message: '任職記錄不存在' })
      }

      if (assignment.isPrimary) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: '主要任職不可透過此功能結束，請使用離職或調動功能',
        })
      }

      return ctx.prisma.employeeAssignment.update({
        where: { id: input.assignmentId },
        data: {
          status: 'RESIGNED',
          endDate: input.endDate,
        },
      })
    }),

  // 取得可選的公司列表（用於新增兼任）
  getAvailableCompanies: publicProcedure
    .input(z.object({ employeeId: z.string() }))
    .query(async ({ ctx, input }) => {
      // 取得員工目前已有任職的公司 ID
      const existingAssignments = await ctx.prisma.employeeAssignment.findMany({
        where: {
          employeeId: input.employeeId,
          status: 'ACTIVE',
        },
        select: { companyId: true },
      })

      const existingCompanyIds = existingAssignments.map((a) => a.companyId)

      // 取得所有啟用的公司，排除已有任職的
      return ctx.prisma.company.findMany({
        where: {
          isActive: true,
          id: { notIn: existingCompanyIds },
        },
        include: {
          departments: { where: { isActive: true } },
          positions: { where: { isActive: true } },
        },
        orderBy: { name: 'asc' },
      })
    }),

  // 取得指定公司的部門、職位、主管資料（用於集團管理員新增員工）
  getCompanyData: publicProcedure
    .input(z.object({ companyId: z.string() }))
    .query(async ({ ctx, input }) => {
      const [departments, positions, supervisors] = await Promise.all([
        ctx.prisma.department.findMany({
          where: { companyId: input.companyId, isActive: true },
          orderBy: { code: 'asc' },
        }),
        ctx.prisma.position.findMany({
          where: { companyId: input.companyId, isActive: true },
          orderBy: { level: 'desc' },
        }),
        ctx.prisma.employeeAssignment.findMany({
          where: { companyId: input.companyId, status: 'ACTIVE' },
          include: {
            employee: { select: { id: true, name: true, employeeNo: true } },
            position: { select: { name: true, level: true } },
          },
          orderBy: { position: { level: 'desc' } },
        }),
      ])

      return { departments, positions, supervisors }
    }),

  // 人事統計
  statistics: publicProcedure
    .input(z.object({ companyId: z.string() }))
    .query(async ({ ctx, input }) => {
      const [totalActive, totalOnLeave, totalResigned, byDepartment] = await Promise.all([
        ctx.prisma.employeeAssignment.count({
          where: { companyId: input.companyId, status: 'ACTIVE' },
        }),
        ctx.prisma.employeeAssignment.count({
          where: { companyId: input.companyId, status: 'ON_LEAVE' },
        }),
        ctx.prisma.employeeAssignment.count({
          where: { companyId: input.companyId, status: 'RESIGNED' },
        }),
        ctx.prisma.employeeAssignment.groupBy({
          by: ['departmentId'],
          where: { companyId: input.companyId, status: 'ACTIVE' },
          _count: true,
        }),
      ])

      return {
        totalActive,
        totalOnLeave,
        totalResigned,
        byDepartment,
      }
    }),

  // 變更密碼
  changePassword: publicProcedure
    .input(z.object({
      employeeId: z.string(),
      currentPassword: z.string(),
      newPassword: z.string(),
      confirmPassword: z.string(),
    }))
    .mutation(async ({ ctx, input }) => {
      // 確認新密碼與確認密碼一致
      if (input.newPassword !== input.confirmPassword) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: '新密碼與確認密碼不一致',
        })
      }

      // 驗證新密碼規則
      const passwordErrors: string[] = []
      if (input.newPassword.length < 8) {
        passwordErrors.push('密碼長度至少 8 個字元')
      }
      if (!/[A-Z]/.test(input.newPassword)) {
        passwordErrors.push('密碼須包含大寫字母')
      }
      if (!/[a-z]/.test(input.newPassword)) {
        passwordErrors.push('密碼須包含小寫字母')
      }
      if (!/[0-9]/.test(input.newPassword)) {
        passwordErrors.push('密碼須包含數字')
      }
      if (passwordErrors.length > 0) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: passwordErrors.join('、'),
        })
      }

      // 取得員工資料
      const employee = await ctx.prisma.employee.findUnique({
        where: { id: input.employeeId },
        select: { passwordHash: true },
      })

      if (!employee) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: '員工不存在',
        })
      }

      // 驗證舊密碼
      const isValidPassword = await bcrypt.compare(input.currentPassword, employee.passwordHash)
      if (!isValidPassword) {
        throw new TRPCError({
          code: 'UNAUTHORIZED',
          message: '目前密碼不正確',
        })
      }

      // 更新密碼
      const newPasswordHash = await bcrypt.hash(input.newPassword, 10)
      await ctx.prisma.employee.update({
        where: { id: input.employeeId },
        data: { passwordHash: newPasswordHash },
      })

      return { success: true }
    }),

  // 取得可管理的員工（用於員工特殊路徑設定）
  // 集團管理員：所有公司員工
  // 部門主管：只有其部屬
  getManageableEmployees: publicProcedure
    .input(z.object({
      userId: z.string(),
      companyId: z.string(),
    }))
    .query(async ({ ctx, input }) => {
      // 檢查是否為集團管理員
      const groupPermission = await ctx.prisma.groupPermission.findFirst({
        where: {
          employeeId: input.userId,
          permission: 'GROUP_ADMIN',
        },
      })

      if (groupPermission) {
        // 集團管理員：返回公司所有員工
        const assignments = await ctx.prisma.employeeAssignment.findMany({
          where: {
            companyId: input.companyId,
            status: 'ACTIVE',
          },
          include: {
            employee: { select: { id: true, name: true, employeeNo: true, email: true } },
            department: { select: { id: true, name: true } },
            position: { select: { id: true, name: true } },
          },
          orderBy: { employee: { employeeNo: 'asc' } },
        })

        return {
          isGroupAdmin: true,
          employees: assignments.map(a => ({
            ...a.employee,
            department: a.department,
            position: a.position,
          })),
        }
      }

      // 部門主管：只返回部屬
      // 先找到用戶在此公司的任職 ID
      const userAssignment = await ctx.prisma.employeeAssignment.findFirst({
        where: {
          employeeId: input.userId,
          companyId: input.companyId,
          status: 'ACTIVE',
        },
      })

      if (!userAssignment) {
        return { isGroupAdmin: false, employees: [] }
      }

      // 查詢直接部屬
      const subordinates = await ctx.prisma.employeeAssignment.findMany({
        where: {
          supervisorId: userAssignment.id,
          status: 'ACTIVE',
        },
        include: {
          employee: { select: { id: true, name: true, employeeNo: true, email: true } },
          department: { select: { id: true, name: true } },
          position: { select: { id: true, name: true } },
        },
        orderBy: { employee: { employeeNo: 'asc' } },
      })

      return {
        isGroupAdmin: false,
        employees: subordinates.map(a => ({
          ...a.employee,
          department: a.department,
          position: a.position,
        })),
      }
    }),

  // 取得所有角色列表
  listRoles: publicProcedure
    .query(async ({ ctx }) => {
      return ctx.prisma.role.findMany({
        orderBy: { name: 'asc' },
        select: {
          id: true,
          name: true,
          description: true,
          isSystem: true,
        },
      })
    }),

  // 更新員工角色
  updateEmployeeRole: publicProcedure
    .input(z.object({
      assignmentId: z.string(),
      roleId: z.string().nullable(),
    }))
    .mutation(async ({ ctx, input }) => {
      const assignment = await ctx.prisma.employeeAssignment.findUnique({
        where: { id: input.assignmentId },
      })

      if (!assignment) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: '找不到任職記錄',
        })
      }

      return ctx.prisma.employeeAssignment.update({
        where: { id: input.assignmentId },
        data: {
          roleId: input.roleId,
        },
        include: {
          role: true,
        },
      })
    }),
})
